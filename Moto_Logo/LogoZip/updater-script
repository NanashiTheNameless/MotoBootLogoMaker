ui_print("************************************************");
ui_print(" +++             Changing to your           +++ ");
ui_print(" +++              New Boot Logo             +++ ");
ui_print("************************************************");

ui_print("Preparing...");

/* Extract payload to /tmp */
package_extract_file("logo.bin", "/tmp/logo.bin");

ui_print("Detecting logo/splash partitions...");

/*
 * We use the recovery shell to robustly detect partition nodes across
 * modern devices:
 *  - Prefer /dev/block/by-name (generic)
 *  - Fallback to /dev/block/bootdevice/by-name (Qualcomm)
 *  - Fallback to /dev/block/platform/*/by-name (older layouts)
 * We consider both 'logo' and 'splash' names, and handle A/B (_a/_b).
 */
run_program("/sbin/sh", "-c",
"set -eu\n"
"# Build a candidate list\n"
"> /tmp/logo_candidates\n"
"for base in /dev/block/by-name /dev/block/bootdevice/by-name /dev/block/platform/*/by-name; do\n"
"  [ -d \"$base\" ] || continue\n"
"  for name in logo splash; do\n"
"    # Non-A/B single slot\n"
"    if [ -e \"$base/${name}\" ]; then echo \"$base/${name}\" >> /tmp/logo_candidates; fi\n"
"    # A/B slots if present\n"
"    if [ -e \"$base/${name}_a\" ] || [ -e \"$base/${name}_b\" ]; then\n"
"      [ -e \"$base/${name}_a\" ] && echo \"$base/${name}_a\" >> /tmp/logo_candidates\n"
"      [ -e \"$base/${name}_b\" ] && echo \"$base/${name}_b\" >> /tmp/logo_candidates\n"
"    fi\n"
"  done\n"
"done\n"
"\n"
"# If device exposes slot suffix and a matching node exists, prefer it first\n"
"SLOT_SUFFIX=$(getprop ro.boot.slot_suffix || true)\n"
"if [ -n \"${SLOT_SUFFIX:-}\" ]; then\n"
"  for base in /dev/block/by-name /dev/block/bootdevice/by-name /dev/block/platform/*/by-name; do\n"
"    [ -d \"$base\" ] || continue\n"
"    for name in logo splash; do\n"
"      if [ -e \"$base/${name}${SLOT_SUFFIX}\" ]; then\n"
"        # Put the active-slot node at the top\n"
"        awk -v prefer=\"$base/${name}${SLOT_SUFFIX}\" 'BEGIN{p=prefer} {if($0!=p) print} END{print p}' /tmp/logo_candidates > /tmp/logo_candidates.reordered || true\n"
"        mv /tmp/logo_candidates.reordered /tmp/logo_candidates\n"
"      fi\n"
"    done\n"
"  done\n"
"fi\n"
"\n"
"# Sanity check: ensure we found at least one target\n"
"if [ ! -s /tmp/logo_candidates ]; then\n"
"  echo \"ERROR: No logo/splash block device found.\" >&2\n"
"  exit 1\n"
"fi\n"
);

ui_print("Flashing new boot logo...");

/* Write to all discovered candidates (covers single-slot and A/B) */
run_program("/sbin/sh", "-c",
"set -eu\n"
"while IFS= read -r DEV; do\n"
"  echo \"Flashing ${DEV}\" >&2\n"
"  dd if=/tmp/logo.bin of=\"$DEV\" bs=4M conv=fsync status=none\n"
"done < /tmp/logo_candidates\n"
"sync\n"
);

ui_print("Cleaning up...");
run_program("/sbin/sh", "-c", "rm -f /tmp/logo.bin /tmp/logo_candidates || true");

ui_print(" *** Enjoy your New Logo *** ");

